# tree-sharking 详解

## 原理

tree-shaking 的消除原理是依赖于 ES6 的模块特性

- 只能作为模块顶层的语句出现
- import 的模块名只能是字符串常量
- import binding 是 immutable 的

ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，然后进行消除，这就是 tree-shaking 的基础。

所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6 之前的模块化，比如我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。

这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。

而 tree-sharking 失败的原因是副作用，什么是副作用？

## 副作用

副作用大致可以理解为一个函数会、或者可能会对函数外部变量产生影响的行为

- 函数的参数若是引用类型，对于它属性的操作，都是有可能会产生副作用的。因为首先它是引用类型，对它属性的任何修改其实都是改变了函数外部的数据。其次获取或修改它的属性，会触发 getter 或者 setter，而 getter、setter 是不透明的，有可能会产生副作用
- uglify 没有完善的程序流分析。它可以简单的判断变量后续是否被引用、修改，但是不能判断一个变量完整的修改过程，不知道它是否已经指向了外部变量，所以很多有可能会产生副作用的代码，都只能保守的不删除
- rollup 有程序流分析的功能，可以更好的判断代码是否真正会产生副作用

## 使用 rollup 打包 JavaScript 库

打包工具库、组件库，还是 rollup 好用，因为：

1. 它支持导出 ES 模块的包
2. 它支持程序流分析，能更加正确的判断项目本身的代码是否有副作用

只要通过 rollup 打出两份文件，一份 umd 版，一份 ES 模块版，它们的路径分别设为 `main`，`module` 的值。这样就能方便使用者进行 tree-shaking。

## 使用 webpack 打包工程化项目

先进行 tree-shaking，再进行编译，减少编译带来的副作用，从而增加 tree-shaking 的效果

## 总结

在当下阶段，在 tree-shaking 上能够尽力的事：

1. 尽量不写带有副作用的代码。诸如编写了立即执行函数，在函数里又使用了外部变量等
2. 如果对 ES6 语义特性要求不是特别严格，可以开启 babel 的 `loose` 模式，这个要根据自身项目判断，如：是否真的要不可枚举 class 的属性
3. 如果是开发 JavaScript 库，请使用 rollup。并且提供 ES6 module 的版本，入口文件地址设置到 `package.json` 的 `module` 字段
4. 如果 JavaScript 库开发中，难以避免的产生各种副作用代码，可以将功能函数或者组件，打包成单独的文件或目录，以便于用户可以通过目录去加载。如有条件，也可为自己的库开发单独的 webpack-loader，便于用户按需加载
5. 如果是工程项目开发，对于依赖的组件，只能看组件提供者是否有对应上述 3、4 点的优化。对于自身的代码，除 1、2 两点外，对于项目有极致要求的话，可以先进行打包，最终再进行编译
6. 如果对项目非常有把握，可以通过 `uglify` 的一些编译配置，如：pure_getters: true，删除一些强制认为不会产生副作用的代码

## 参考文章

- [你的 Tree-Shaking 并没什么卵用](https://juejin.im/post/6844903549290151949#heading-8)
- [Tree-Shaking 性能优化实践 - 原理篇](https://juejin.im/post/6844903544756109319)
