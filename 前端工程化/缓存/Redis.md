# Redis 缓存

Redis 缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。

## 缓存处理流程

- 参数传入对象主键 ID
- 根据 key 从缓存中获取对象
- 如果对象不为空，直接返回
- 如果对象为空，进行数据库查询
- 如果从数据库查询出的对象不为空，则放入缓存（设定过期时间）

## 缓存穿透

**描述：**

缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为 id 为“-1”的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

**解决方案：**

- 接口层增加校验，如用户鉴权校验，id 做基础校验，id<=0 的直接拦截
- 从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个 id 暴力攻击

## 缓存击穿

**描述：**

缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，`同时`去读缓存没读到数据，又`同时`去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

**解决方案：**

- 设置热点数据永远不过期
- 加互斥锁，互斥锁参考代码：

```java
public static String getData(String key) throws InterruptedException {
  // 从缓存读取数据
  String result = getDataFromRedis(key);
  // 缓存中不存在数据
  if(result == null){
    // 去获取锁，获取成功，去数据库请求数据
    if(reenLock.tryLock()){
      // 从数据库获取数据
      result = getDataFromMysql(key);
      // 更新缓存数据
      if(result == null){
        setDataToCache(key, result);
      }
      // 释放锁
      reenLock.unLock();
    } else {
      // 获取锁失败，暂停 100ms 再去去数据
      Thread.sleep(100);
      result = getData(key);
    }
  }
  return result;
}
```

**说明：**

1. 缓存中有数据，直接走上述代码 13 行后就返回结果了

2. 缓存中没有数据，第 1 个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待 100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。

3. 当然这是简化处理，理论上如果能根据 key 值加锁就更好了，就是线程 A 从数据库取 key1 的数据并不妨碍线程 B 取 key2 的数据，上面代码明显做不到这点。

## 缓存雪崩

**描述：**

缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机。和缓存击穿不同的是， 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

**解决方案：**

- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
- 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
- 设置热点数据永远不过期。
