(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{563:function(a,t,e){"use strict";e.r(t);var s=e(55),i=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"浏览器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[a._v("#")]),a._v(" 浏览器缓存")]),a._v(" "),e("h3",{attrs:{id:"web-缓存的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web-缓存的作用"}},[a._v("#")]),a._v(" Web 缓存的作用")]),a._v(" "),e("ul",[e("li",[a._v("减少网络带宽消耗")]),a._v(" "),e("li",[a._v("降低服务器压力")]),a._v(" "),e("li",[a._v("减少网络延迟，加快页面打开速度")])]),a._v(" "),e("h3",{attrs:{id:"web-缓存的类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web-缓存的类型"}},[a._v("#")]),a._v(" Web 缓存的类型")]),a._v(" "),e("ul",[e("li",[a._v("数据库数据缓存")]),a._v(" "),e("li",[a._v("服务器端缓存")]),a._v(" "),e("li",[a._v("浏览器端缓存")]),a._v(" "),e("li",[a._v("Web 应用层缓存")])]),a._v(" "),e("h3",{attrs:{id:"浏览器端的缓存规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器端的缓存规则"}},[a._v("#")]),a._v(" 浏览器端的缓存规则")]),a._v(" "),e("ul",[e("li",[a._v("新鲜度（过期机制）：也就是缓存副本的有效期，一个缓存副本必须满足以下任一条件，浏览器才会认为它是有效的，足够新的，从而直接从缓存中获取副本并渲染\n"),e("ol",[e("li",[a._v("含有完整的过期时间控制头信息（HTTP 协议报头），并且仍在有效期内")]),a._v(" "),e("li",[a._v("浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度")])])]),a._v(" "),e("li",[a._v("校验值（验证机制）： 服务器返回资源的时候有时在控制头信息带上这个资源的实体标签 Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如果发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。")])]),a._v(" "),e("h3",{attrs:{id:"浏览器缓存的控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存的控制"}},[a._v("#")]),a._v(" 浏览器缓存的控制")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("使用 HTML 的 Meta 标签")]),a._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[a._v("// 浏览器当前页面不被缓存，每次访问都需要去服务器拉取\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("meta")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("http-equiv")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')]),a._v("Pragma"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')])]),a._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("content")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')]),a._v("no-cache"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')])]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("/>")])]),a._v("\n")])])])]),a._v(" "),e("li",[e("p",[a._v("使用缓存有关的 HTTP 消息报头")]),a._v(" "),e("p",[a._v("一个 URL 的完整 HTTP 协议交互过程是由 HTTP 请求和 HTTP 响应组成的，在 HTTP 请求和响应的消息报头中，常见的与缓存有关的消息报头有：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://xinpuchen.github.io/images/http-cache-relevant.png",alt:""}})])])]),a._v(" "),e("p",[a._v("以下对各报头进行解释：")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("Cache-Control\n包括以下字段：")]),a._v(" "),e("ul",[e("li",[a._v("max-age（单位为 s）：指定设置缓存最大的有效时间，定义的是时间长短。max-age 会覆盖掉 Expires。")]),a._v(" "),e("li",[a._v("s-maxage（单位为 s）：同 max-age，只用于共享缓存（比如 CDN 缓存）。比如，当 s-maxage=60 时，在这 60 秒中，即使更新了 CDN 的内容，浏览器也不会进行请求。也就是说 max-age 用于普通缓存，而 s-maxage 用于代理缓存。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。")]),a._v(" "),e("li",[a._v("public：指定响应会被缓存，并且在多用户间共享，包括终端用户和 CDN 等中间代理服务器。如果没有指定 public 还是 private，则默认为 public。")]),a._v(" "),e("li",[a._v("private：响应只作为私有的缓存，不能在用户间共享。如果要求 HTTP 认证，响应会自动设置为 private。")]),a._v(" "),e("li",[a._v("no-cache：指定不缓存响应，表明资源不进行缓存，但是设置了 no-cache 之后并不代表浏览器不缓存，而是在获取缓存前要向服务器确认资源是否被更改。因此有的时候只设置 no-cache 防止缓存还是不够保险，还可以加上 private 指令，将过期时间设为过去的时间。")]),a._v(" "),e("li",[a._v("no-store：绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存啦～每次请求资源都要从服务器重新获取。")]),a._v(" "),e("li",[a._v("must-revalidate：指定如果页面是过期的，则去服务器进行获取。这个指令并不常用。")])]),a._v(" "),e("p",[e("img",{attrs:{src:"https://xinpuchen.github.io/images/cache-control.png",alt:""}})])]),a._v(" "),e("li",[e("p",[a._v("Expires：缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说， Expires=max-age + 请求时间 ，需要和 Last-modified 结合使用。但在上面我们提到过，cache-control 的优先级更高。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。")])]),a._v(" "),e("li",[e("p",[a._v("Last-modified & If-modified-since：务器端文件的最后修改时间，需要和 cache-control 共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送 If-Modified-Since 报头，询问 Last-Modified 时间点之后资源是否被修改过。如果没有修改，则返回码为 304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为 200，资源为服务器最新资源。")])]),a._v(" "),e("li",[e("p",[a._v("Etag & If-None-Match：与 Last-Modify/If-Modify-Since 不同的是，Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。")])])]),a._v(" "),e("h3",{attrs:{id:"缓存报头种类与优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存报头种类与优先级"}},[a._v("#")]),a._v(" 缓存报头种类与优先级")]),a._v(" "),e("h4",{attrs:{id:"cache-control-与-expires"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-与-expires"}},[a._v("#")]),a._v(" Cache-Control 与 Expires")]),a._v(" "),e("p",[a._v("Cache-Control 与 Expires 的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过 Cache-Control 的选择更多，设置更细致，如果同时设置的话，其优先级高于 Expires。")]),a._v(" "),e("h4",{attrs:{id:"last-modified-与-etag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-与-etag"}},[a._v("#")]),a._v(" Last-Modified 与 ETag")]),a._v(" "),e("p",[a._v("你可能会觉得使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 Etag（实体标识）呢？HTTP1.1 中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题：")]),a._v(" "),e("ul",[e("li",[a._v("Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度。")]),a._v(" "),e("li",[a._v("如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存。")]),a._v(" "),e("li",[a._v("有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。")])]),a._v(" "),e("p",[a._v("Etag 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。")]),a._v(" "),e("h4",{attrs:{id:"last-modified-etag-与-cache-control-expires"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-etag-与-cache-control-expires"}},[a._v("#")]),a._v(" Last-Modified/ETag 与 Cache-Control/Expires")]),a._v(" "),e("p",[a._v("配置 Last-Modified/ETag 的情况下，浏览器再次访问统一 URI 的资源，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器会只发送一个 304 回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器；")]),a._v(" "),e("p",[a._v("Cache-Control/Expires 则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。两者一起使用时， Cache-Control/Expires 的优先级要高，即当本地副本根据 Cache-Control/Expires 发现还在有效期内时，则不会再次发送请求去服务器询问修改时间 Last-Modified 或实体标识 Etag 了。")]),a._v(" "),e("p",[a._v("一般情况下，两者会配合一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时 Last-Modified/ETag 将能够很好利用 304，从而减少响应开销。")]),a._v(" "),e("h3",{attrs:{id:"使用缓存的流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用缓存的流程"}},[a._v("#")]),a._v(" 使用缓存的流程")]),a._v(" "),e("p",[a._v("一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取并展示资源：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://xinpuchen.github.io/images/user-request-process.png",alt:""}})]),a._v(" "),e("p",[a._v("缓存行为主要由缓存策略决定，而缓存策略由内容拥有者设置。这些策略主要通过特定的 HTTP 头部来清晰地表达。")]),a._v(" "),e("p",[a._v("以上过程也可以被概括为三个阶段：")]),a._v(" "),e("ul",[e("li",[a._v("本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这个资源，完全不会发送 http 请求到服务器；")]),a._v(" "),e("li",[a._v("协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个 http 请求到服务器，然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回 304，让浏览器使用本地找到的那个资源；")]),a._v(" "),e("li",[a._v("缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(没有找到资源)，服务器则返回该资源的数据，并且返回 200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回 404。")])]),a._v(" "),e("h3",{attrs:{id:"用户操作行为与缓存的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用户操作行为与缓存的关系"}},[a._v("#")]),a._v(" 用户操作行为与缓存的关系")]),a._v(" "),e("p",[a._v("用户在使用浏览器的时候，会有各种操作，比如输入地址后回车，按 F5 刷新等，这些行为会对缓存有什么影响呢？")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://xinpuchen.github.io/images/browser-action-cache.png",alt:""}})]),a._v(" "),e("p",[a._v("通过上表我们可以看到，当用户在按 F5 进行刷新的时候，会忽略 Expires/Cache-Control 的设置，会再次发送请求去服务器请求，而 Last-Modified/Etag 还是有效的，服务器会根据情况判断返回 304 还是 200。")]),a._v(" "),e("ul",[e("li",[a._v("普通刷新：当按下 F5 或者点击刷新按钮来刷新页面的时候，浏览器将绕过本地缓存来发送请求到服务器, 此时, 协商缓存是有效的。")]),a._v(" "),e("li",[a._v("强制刷新：当按下 ctrl+F5 来刷新页面的时候, 浏览器将绕过各种缓存(本地缓存和协商缓存), 直接让服务器返回最新的资源。")]),a._v(" "),e("li",[a._v("回车或转向：当在地址栏上输入回车或者按下跳转按钮的时候, 所有缓存都生效")])]),a._v(" "),e("h3",{attrs:{id:"如何从缓存角度改善站点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何从缓存角度改善站点"}},[a._v("#")]),a._v(" 如何从缓存角度改善站点")]),a._v(" "),e("ul",[e("li",[a._v("同一个资源保证 URL 的稳定性")]),a._v(" "),e("li",[a._v("给 css、js、图片等资源增加 HTTP 缓存头，并强制入口 html 不被缓存")]),a._v(" "),e("li",[a._v("减少对 Cookie 的依赖")]),a._v(" "),e("li",[a._v("减少对 HTTPS 加密协议的使用")]),a._v(" "),e("li",[a._v("多用 Get 方式请求动态 Cgi")]),a._v(" "),e("li",[a._v("动态 CGI 也是可以被缓存")])])])}),[],!1,null,null,null);t.default=i.exports}}]);