(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{467:function(t,a,e){"use strict";e.r(a);var r=e(55),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"script-标签-defer-与-async-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#script-标签-defer-与-async-的区别"}},[t._v("#")]),t._v(" script 标签 defer 与 async 的区别")]),t._v(" "),e("h2",{attrs:{id:"defer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#defer"}},[t._v("#")]),t._v(" defer")]),t._v(" "),e("p",[t._v("这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在 script 元素中设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。")]),t._v(" "),e("blockquote",[e("p",[t._v("HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 DOMContentLoaded 事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoad 时间触发前执行，因此最好只包含一个延迟脚本。")])]),t._v(" "),e("h2",{attrs:{id:"async"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[t._v("#")]),t._v(" async")]),t._v(" "),e("p",[t._v("这个属性与 defer 类似，都用于改变处理脚本的行为。同样与 defer 类似，async 只适用于外部脚本文件，并告诉浏览器立即下载文件。但与 defer 不同的是，标记为 async 的脚本并不保证按照它们的先后顺序执行。")]),t._v(" "),e("blockquote",[e("p",[t._v("第二个脚本文件可能会在第一个脚本文件之前执行。因此确保两者之间互不依赖非常重要。指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://segmentfault.com/img/bVCBBR",alt:"img"}})]),t._v(" "),e("blockquote",[e("p",[t._v("蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。")])]),t._v(" "),e("p",[t._v("也就是说 async 是乱序的，而 defer 是顺序执行，这也就决定了 async 比较适用于百度分析或者谷歌分析这类不依赖其他脚本的库。从图中可以看到一个普通的 script 标签的加载和解析都是同步的，会阻塞 DOM 的渲染，这也就是我们经常会把 script 写在 body 底部的原因之一，为了防止加载资源而导致的长时间的白屏，另一个原因是 js 可能会进行 DOM 操作，所以要在 DOM 全部渲染完后再执行。")]),t._v(" "),e("h2",{attrs:{id:"really"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#really"}},[t._v("#")]),t._v(" really?")]),t._v(" "),e("p",[t._v("然而，这张图（几乎是百度搜到的唯一答案）是不严谨的，这只是规范的情况，大多数浏览器在实现的时候会作出优化。")]),t._v(" "),e("p",[t._v("来看看 chrome 是怎么做的:")]),t._v(" "),e("p",[t._v("《WebKit 技术内幕》：")]),t._v(" "),e("ol",[e("li",[t._v("当用户输入网页 URL 的时候，WebKit 调用其资源加载器加载该 URL 对应的网页。")]),t._v(" "),e("li",[t._v("加载器依赖网络模块建立连接，发送请求并接受答复。")]),t._v(" "),e("li",[t._v("WebKit 接收到各种网页或者资源的数据，其中某些资源可能是同步或异步获取的。")]),t._v(" "),e("li",[t._v("网页被交给 HTML 解释器转变成一系列的词语（Token）。")]),t._v(" "),e("li",[t._v("解释器根据词语构建节点（Node），形成 DOM 树。")]),t._v(" "),e("li",[t._v("如果节点是 JavaScript 代码的话，调用 JavaScript 引擎解释并执行。")]),t._v(" "),e("li",[t._v("JavaScript 代码可能会修改 DOM 树的结构。")]),t._v(" "),e("li",[t._v("如果节点需要依赖其他资源，例如图片、CSS、视频等，调用资源加载器来加载他们，但是他们是异步的，不会阻碍当前 DOM 树的继续创建；如果是 JavaScript 资源 URL（没有标记异步方式），则需要停止当前 DOM 树的创建，直到 JavaScript 的资源加载并被 JavaScript 引擎执行后才继续 DOM 树的创建。")])]),t._v(" "),e("p",[t._v("所以，通俗来讲，chrome 浏览器首先会请求 HTML 文档，然后对其中的各种资源调用相应的资源加载器进行异步网络请求，同时进行 DOM 渲染，直到遇到 script 标签的时候，主进程才会停止渲染等待此资源加载完毕然后调用 V8 引擎对 js 解析，继而继续进行 DOM 解析。我的理解如果加了 async 属性就相当于单独开了一个进程去独立加载和执行，而 defer 是和将 script 放到 body 底部一样的效果。")]),t._v(" "),e("h2",{attrs:{id:"结论："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结论："}},[t._v("#")]),t._v(" 结论：")]),t._v(" "),e("p",[t._v("其实这么讲来，最稳妥的办法还是把 script 写在 body 底部，没有兼容性问题，没有白屏问题，没有执行顺序问题，高枕无忧，不要搞什么 defer 和 async 的花啦~")]),t._v(" "),e("p",[t._v("Hint：https://segmentfault.com/a/1190000006778717")])])}),[],!1,null,null,null);a.default=s.exports}}]);