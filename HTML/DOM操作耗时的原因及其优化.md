# DOM 操作耗时的原因及其优化

无论是对于刚刚开始学习，还是有所基础的前端学习者来说，都听过这么一句话，少用 JS 进行 DOM 操作，性能不好，耗时并且影响用户体验

## DOM 操作原理

> DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML 交互的 API 文档。DOM 是载入到浏览器中的文档模型，它用节点树的形式来表现文档，每个节点代表文档的构成部分（例如： element——页面元素、字符串或注释等等）。 ——MDN

DOM 其实是方便 HTML 组织元素结点的一种抽象对象，而对 DOM 的操作，指的就是我们日常对页面元素进行的操作

对 DOM 的操作其实就跟放大象到冰箱里一样，拿出来，改改改，放回去，并且放回去的操作浏览器帮你做了。(当然也可以自己做，见后文)

其实这类简单的操作并不会给浏览器带来多大的负担，所以说，DOM 操作并不耗时

那么你会问：这么说我听了这么久的耗时说法是错的了？

当然，事出有因，只是表述的时候有所省略了。真正影响我们操作体验的是，我们将变化后的 DOM 结点，放回去，引发的浏览器的`重排`和`重绘`

而且，这其中最为重要的，是**浏览器的渲染机制**，在渲染时，会`阻塞JS`的进程`，避免出现渲染错误，这也是为什么我们要将 JS 文件，放在底部执行的原因

### 重排和重绘

- 重排 reflow：部分 **渲染树需要重新分析** 并且 **节点尺寸需要重新计算**
- 重绘 repaint：由于 **样式** 发生改变,屏幕上的部分内容需要更新

#### 触发重排的操作

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变
- 元素内容变化（文字数量或图片大小等等）
- 元素字体大小变化
- 添加或者删除可见的 DOM 元素
- 激活 CSS 伪类（例如：:hover）
- 查询某些属性或调用某些方法

#### 触发重绘的操作

- 元素样式的改变并不影响它在文档流中的位置时

**重绘不一定重排**

### 耗时情况

说了这么多，我们来看看，到底在什么情况下，我们会感受到 DOM 操作的缓慢

下面是一个对类为 main 的 div 进行填充的操作

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>DOM</title>
  </head>
  <body>
    <div class="main"></div>
    <script>
      let div = document.getElementsByClassName('main');
      let times = 1000;
      console.time('timer');
      for (let i = 0; i < times; i++) {
        let subDiv = document.createElement('div');
        subDiv.innerHTML = `<div>Hello ${i}</div>`;
        div[0].appendChild(subDiv);
      }
      console.timeEnd('timer');
    </script>
  </body>
</html>
```

我使用了尽可能让 DOM 操作慢的代码编写方式，为了让效果更加明显

#### 插入 10 个 div

让 times = 10,我们可以在 console 里看到时间是

```
  timer: 0.39599609375ms
```

#### 插入 100 个 div

```
  timer: 22.204833984375ms
```

#### 插入 1000 个 div

```
  timer: 1176.9072265625ms
```

我们可以从上面的测试中看到，当我们只在同一时刻操作少量的 DOM 结点时，效果并不明显，直到 1000 这个数量级，我们肉眼才会有可见的延迟

**所以，当我们只是编写简单页面时，完全可以不用考虑 DOM 操作延时对我们的影响**
当然，也是因为我们测试使用的例子较为简单，真正在实际的 HTML 页面中，div 元素内可能还会有较多的子 DOM 结点，所以延迟会更加明显

## DOM 操作优化

那么在之后的学习中，随着业务的越来越复杂，我们必不可少的会学习到，如何进行 DOM 优化，下面是几种简单，常用的优化方法

### CSS

- 避免使用 table 布局
- 尽可能在 DOM 树的最末端改变 class
- 避免设置多层内联样式
- 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上
- 避免使用 CSS 表达式（例如：calc()）

### JavaScript

- 尽可能使用 querySelector，而不是使用获取 HTML 集合的 API
- 避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性
- 避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中
- 也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流
- 使用事件委托，减少绑定事件的数量
