# debounce and Throttle

## 防抖和节流的区别：

### 效果：

函数防抖是某一段时间内只执行一次；而函数节流是间隔时间执行，不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。

### 原理：

防抖是维护一个计时器，规定在 delay 时间后触发函数，但是在 delay 时间内再次触发的话，都会清除当前的 timer 然后重新设置超时调用，即重新计时。这样一来，只有最后一次操作能被触发。

节流是通过判断是否到达一定时间来触发函数，若没到规定时间则使用计时器延后，而下一次事件则会重新设定计时器。

## Debounce - 函数防抖

如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。
也就是说当调用动作 n 毫秒后，才会执行该动作，若在这 n 毫秒内又调用此动作则将重新计算执行时间

```js
/**
 * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 delay，action 才会执行
 * @param action {function} 请求关联函数，实际应用需要调用的函数
 * @param delay {number} 空闲时间，单位毫秒
 * @return {function} 返回客户调用函数
 */

var debounce = function(action, delay) {
  var last;
  return function() {
    var _this = this,
      args = arguments;
    clearTimeout(last);
    last = setTimeout(function() {
      action.apply(_this, args);
    }, delay);
  };
};
```

## Throttle - 函数节流

如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。
也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期

```js
/**
 * 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay
 * @param action {function} 请求关联函数，实际应用需要调用的函数
 * @param delay {number} 延迟时间，单位毫秒
 * @return {function} 返回客户调用函数
 */

var throttle = function(action, delay) {
  var last = 0;
  return function() {
    var curr = +new Date();
    if (curr - last > delay) {
      action.apply(this, arguments);
      last = curr;
    }
  };
};
```
